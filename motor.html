<html>
    <body onload="init();">
        <a href="index.html">rew-brian.com</a>
        <h1>DC Motor Simulation</h1>
        <canvas id="canvas" width="800" height="600"></canvas>
        <p>This is a simulation of a simple DC motor control algorithm.<br>
        The rotor (the inner circle) has a north pole (blue) and a south pole (red).<br>
        The stators (the three outer lines) can be energized to create north or south poles.<br>
        The control algorithm energizes the stators based on the rotor's position to create continuous rotation.<br>
        There are more efficient algorithms, but this one is simple to understand.<br>
        </p>
        <script>

// The north pole (blue side) of the rotor faces this direction
var rotorAngle = 0;

let lastTimestamp = null;
function animate(timestamp) {
    requestAnimationFrame(animate);

    // Determine time since the last animation frame and
    // update the rotor angle accordingly.
    const rotorRadiansPerSecond = 0.2;
    if (lastTimestamp !== null) {
        const delta = (timestamp - lastTimestamp) / 1000;
        rotorAngle += rotorRadiansPerSecond * delta;
    }
    lastTimestamp = timestamp;

    // Compute a unit vector representing the rotor's north pole.
    // Here, we're working in standard "math" coordinates with
    // +x to the right, +y up, 0 radians along +x, and increasing angles
    // counterclockwise.
    let rotorVectorX = Math.cos(rotorAngle);
    let rotorVectorY = Math.sin(rotorAngle);

    // The stators are at angles 0, 2π/3, and 4π/3.
    let statorAngles = [0, 2 * Math.PI / 3, 4 * Math.PI / 3];

    // Dot the rotor vector (rotated by 90 degrees) with each stator angle
    let statorDots = statorAngles.map(angle => {
        let statorVectorX = Math.cos(angle);
        let statorVectorY = Math.sin(angle);
        return -rotorVectorY * statorVectorX + rotorVectorX * statorVectorY;
    });

    let statorColors = statorDots.map(dot => {
        if (dot > 0.5) {
            return "red";  // north
        } else if (dot < -0.5) {
            return "blue";  // south
        } else {
            return "gray";  // unpowered
        }
    });

    var ctx = document.getElementById("canvas").getContext("2d");

    // Clear the canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Switch the canvas to use math-like coordinates
    ctx.save();
    ctx.setTransform(1, 0, 0, -1, canvas.width / 2, canvas.height/2);

    const rotorRadius = 100;
    const magnetWidth = 50;

    // Draw the rotor
    ctx.beginPath();
    ctx.arc(0, 0, rotorRadius, 0, 2 * Math.PI);
    ctx.fillStyle = "gray";
    ctx.fill();

    // Draw the rotor's north pole
    ctx.save();
    ctx.lineWidth = magnetWidth;
    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.lineTo(rotorRadius * rotorVectorX, rotorRadius * rotorVectorY);
    ctx.strokeStyle = "blue";
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.lineTo(-rotorRadius * rotorVectorX, -rotorRadius * rotorVectorY);
    ctx.strokeStyle = "red";
    ctx.stroke();
    ctx.restore();

    const statorInnerRadius = 120;
    const statorOuterRadius = 300;
    const statorWidth = 100;

    // Draw the stators
    ctx.save();
    ctx.lineWidth = statorWidth;
    for (let i = 0; i < 3; i++) {
        let angle = statorAngles[i];
        ctx.beginPath();
        ctx.moveTo(statorInnerRadius * Math.cos(angle), statorInnerRadius * Math.sin(angle));
        ctx.lineTo(statorOuterRadius * Math.cos(angle), statorOuterRadius * Math.sin(angle));
        ctx.strokeStyle = statorColors[i];
        ctx.stroke();
    }
    ctx.restore();
    ctx.restore();
}

function init() {
    ctx = document.getElementById("canvas").getContext("2d");

    // The motor is parameterized by the state of the three coils
    // and the orientation of the rotor.  In this animation, we'll
    // slowly spin the rotor and derive the coil states from the
    // rotor angle.

    // Begin the animation loop
    requestAnimationFrame(animate);
}

        </script>
    </body>
</html>