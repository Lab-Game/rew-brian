<html>
    <body onload="init()">
        <a href="index.html">rew-brian.com</a>
        <h1>Elevator Control Simulation</h1>
        <canvas id="canvas" width="800" height="600"></canvas>
        <p>This simulates an FRC elevator.</p>
        <script>

// Basic parameters for Kraken X60 motor
const nominalVoltage = 12.0;
const freeSpeedRPM = 6000;
const freeCurrent = 2;
const stallTorque = 7.09;
const stallCurrent = 366;

// Convert free speed to radians per second
const freeSpeedRadPerSec = freeSpeedRPM / 60 * 2 * Math.PI;

// From the basic motor parameters, we can derive some other
// useful constants:
//
//   Kt = torque per amp
//   Ke = back EMF constant: volts per (rad/sec)
//   Kv = 1 / Ke = rad/sec per volt
//   R = motor resistance
//
// In particular, torque is proportional to current, so we can
// derive Kt from any state where both the torque and current
// are known (e.g., stall):
const kT = stallTorque / stallCurrent;

// And when the motor is stalled, there is no back-EMF.
// So current, voltage, and resistance are related by Ohm's Law:
const R = nominalVoltage / stallCurrent;

// At all times, the voltage supplied to the motor is
// divided between the back EMF and voltage drop across
// the motor coils:
//
//   nominalVoltage = back EMF + voltage drop across coils
//                  = Ke * motor speed + I * R
//
// Rearranging, we have:
//
//   Ke = (nominalVoltage - I * R) / motor speed
//
// We can determine Ke when the motor is running at
// free speed, since we know both the motor speed and current:
const Ke = (nominalVoltage - freeCurrent * R) / freeSpeedRadPerSec;

// People often use kV, the inverse of Ke:
const kV = 1 / Ke;

// Now suppose we want to know how much torque the motor
// provides at a given speed and voltage:
//
//   torque = Kt * I
//          = Kt * (voltage - back-EMF) / R
//          = Kt * (voltage - Ke * motor speed) / R
function getMotorTorque(motorSpeedRadPerSec, voltage) {
    let backEmf = motorSpeedRadPerSec * Ke;
    let current = (voltage - backEmf) / R;
    let torque = kT * current;
    return torque;
}

/*
Now suppose that the motor is lifting a weight, like an elevator
mechanism on an FRC robot.  At each instant, we can compute the
torque generated by the motor.  From the torque, we can compute
the force applied to the elevator.  This force may accelerate
the elevator.  In any case, the speed of the elevator's motion
determines the motor's speed.  (In principle, the elevator could
lower the elevator faster than gravity; gotta look out for that!)
So there's roughly a feedback:
  - Motor voltage + elevator speed -> motor torque
  - Motor torque -> elevator force
  - Elevator force -> elevator acceleration
  - Elevator acceleration -> elevator speed
  - Elevator speed -> motor speed
  - Motor speed + motor voltage -> motor torque, etc.
This should be expressible with a tidy set of differential equations,
which we can integrate numerically over time to simulate the elevator's
behavior.

One extra factor is how motor torque is converted to force on the elevator.
For example, if the motor produces a torque of 1 Nm, and the spool
lifting the elevator has a radius of 0.02 m, then the force on the
elevator is 1 Nm / 0.02 m = 50 N.  This large force might vigorously
accelerate the elevator upward.  But how does this effective down-gearing
of the elevator limit the maximum elevator speed?

I guess the elevator 

State varibles are:

*/

const inchesToPixels = 8;  // 1 inch = 10 pixels

function drawElevator(ctx, heightInches) {
    heightInches = Math.max(0, Math.min(20, heightInches));
    const heightPixels = heightInches * inchesToPixels;

    // Clear the canvas
    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);

    // Draw the lower elevator stage
    ctx.strokeStyle = "gray";
    ctx.lineWidth = 10;
    ctx.beginPath();
    ctx.rect(150, 300, 200, 255);
    ctx.stroke();

    // Draw the upper elevator stage
    ctx.strokeStyle = "lightgray";
    ctx.beginPath();
    ctx.rect(160, 290 - heightPixels, 180, 250);
    ctx.stroke();

    // Draw the robot base
    ctx.fillStyle = "blue";
    ctx.beginPath();
    ctx.roundRect(100, 550, 300, 50, 10);
    ctx.fill();

    // Put the team number, 6962, on the robot base
    ctx.textAlign = "center";
    ctx.fillStyle = "white";
    ctx.font = "30px Arial";
    ctx.fillText("6962", 250, 585);

    // Print the elevator height.
    ctx.fillStyle = "black";
    ctx.font = "20px Arial";
    ctx.fillText("height = " + heightInches + " in", 250, 280 - heightPixels);
}

function simulate() {
    // Simulate motor behavior over time.  This is a rough draft.
    let motorSpeed = 0.0;
    let kV = 0.012;  // volts per (rad/sec)
    let Vsupply = 12.0;  // volts
    for (let t = 0; t < 1; t += 0.0001) {
        let backEmf = motorSpeed * kV;
        let voltageApplied = Vsupply - backEmf;
        let motorAcceleration = voltageApplied * 0.1;  // rad/sec^2 per volt
        motorSpeed += motorAcceleration * 0.0001;
    }
}

function init() {
    var ctx = document.getElementById("canvas").getContext("2d");

    // Valid heights are 0 to 200.
    drawElevator(ctx, 10);
}

        </script>
    </body>
</html>