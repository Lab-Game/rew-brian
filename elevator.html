<html>
    <body onload="init()">
        <a href="index.html">rew-brian.com</a>
        <h1>Elevator Control Simulation</h1>
        <canvas id="canvas" width="800" height="600"></canvas>
        <p>This simulates an FRC elevator.</p>
        <script>

// Basic parameters for Kraken X60 motor
const nominalVoltage = 12.0;
const freeSpeedRPM = 6000;
const freeCurrent = 2;
const stallTorque = 7.09;
const stallCurrent = 366;

// Convert free speed to radians per second
const freeSpeedRadPerSec = freeSpeedRPM / 60 * 2 * Math.PI;

// From the basic motor parameters, we can derive some other
// useful constants:
//
//   Kt = torque per amp
//   Ke = back EMF constant: volts per (rad/sec)
//   Kv = 1 / Ke = rad/sec per volt
//   R = motor resistance
//
// In particular, torque is proportional to current, so we can
// derive Kt from any state where both the torque and current
// are known (e.g., stall):
const kT = stallTorque / stallCurrent;

// And when the motor is stalled, there is no back-EMF.
// So current, voltage, and resistance are related by Ohm's Law:
const R = nominalVoltage / stallCurrent;

// At all times, the voltage supplied to the motor is
// divided between the back EMF and voltage drop across
// the motor coils:
//
//   nominalVoltage = back EMF + voltage drop across coils
//                  = Ke * motor speed + I * R
//
// Rearranging, we have:
//
//   Ke = (nominalVoltage - I * R) / motor speed
//
// We can determine Ke when the motor is running at
// free speed, since we know both the motor speed and current:
const Ke = (nominalVoltage - freeCurrent * R) / freeSpeedRadPerSec;

// People often use kV, the inverse of Ke:
const kV = 1 / Ke;

// Now suppose we want to know how much torque the motor
// provides at a given speed and voltage:
//
//   torque = Kt * I
//          = Kt * (voltage - back-EMF) / R
//          = Kt * (voltage - Ke * motor speed) / R
function getMotorTorque(motorSpeedRadPerSec, voltage) {
    let backEmf = motorSpeedRadPerSec * Ke;
    let current = (voltage - backEmf) / R;
    let torque = kT * current;
    return torque;
}

const inchesToPixels = 8;  // 1 inch = 10 pixels

function drawElevator(ctx, heightInches) {
    heightInches = Math.max(0, Math.min(20, heightInches));
    const heightPixels = heightInches * inchesToPixels;

    // Clear the canvas
    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);

    // Draw the lower elevator stage
    ctx.strokeStyle = "gray";
    ctx.lineWidth = 10;
    ctx.beginPath();
    ctx.rect(150, 300, 200, 255);
    ctx.stroke();

    // Draw the upper elevator stage
    ctx.strokeStyle = "lightgray";
    ctx.beginPath();
    ctx.rect(160, 290 - heightPixels, 180, 250);
    ctx.stroke();

    // Draw the robot base
    ctx.fillStyle = "blue";
    ctx.beginPath();
    ctx.roundRect(100, 550, 300, 50, 10);
    ctx.fill();

    // Put the team number, 6962, on the robot base
    ctx.textAlign = "center";
    ctx.fillStyle = "white";
    ctx.font = "30px Arial";
    ctx.fillText("6962", 250, 585);

    // Print the elevator height.
    ctx.fillStyle = "black";
    ctx.font = "20px Arial";
    ctx.fillText("height = " + heightInches + " in", 250, 280 - heightPixels);
}

function simulate() {
    // Simulate motor behavior over time.  This is a rough draft.
    let motorSpeed = 0.0;
    let kV = 0.012;  // volts per (rad/sec)
    let Vsupply = 12.0;  // volts
    for (let t = 0; t < 1; t += 0.0001) {
        let backEmf = motorSpeed * kV;
        let voltageApplied = Vsupply - backEmf;
        let motorAcceleration = voltageApplied * 0.1;  // rad/sec^2 per volt
        motorSpeed += motorAcceleration * 0.0001;
    }
}

function init() {
    var ctx = document.getElementById("canvas").getContext("2d");

    // Valid heights are 0 to 200.
    drawElevator(ctx, 10);
}

        </script>
    </body>
</html>